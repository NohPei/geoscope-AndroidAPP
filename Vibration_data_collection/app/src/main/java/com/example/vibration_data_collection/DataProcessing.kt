package com.example.vibration_data_collection

import android.content.Context
import androidx.compose.runtime.mutableStateOf
import org.eclipse.paho.client.mqttv3.MqttMessage
import org.json.JSONObject
import java.io.File
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

data class DataFrame(
    val uuid: String,
    val data: List<Int>,
    val gain: Double,
    val sendTime: Long
) {
    companion object {
        fun fromJson(jsonString: String): DataFrame {
            val jsonObject = JSONObject(jsonString)
            val uuid = jsonObject.getString("uuid")
            val dataArray = jsonObject.getJSONArray("data")
            val dataList = List(dataArray.length()) { dataArray.getInt(it) }
            val gain = jsonObject.getDouble("gain")
            val sendTime = jsonObject.getLong("sendTime")
            return DataFrame(uuid, dataList, gain, sendTime)
        }
    }
}

fun mqttMessageHandler(
    topic: String?,
    message: MqttMessage?,
    devices: MutableList<Device>,
    mainActivity: MainActivity
) {
    // The message is in json format, parse them into a data structure called DataFrame defined above
    val jsonString = message?.toString() ?: return
    try {
        val dataFrame = DataFrame.fromJson(jsonString)
        val device = devices.find { it.topic == topic }

        device?.addDataFrame(dataFrame)

        if (mainActivity.isPlaying) {
            device?.extractEntries(mainActivity.plotLength, 0, false) // update the entry list if plotting real-time
            mainActivity.sliderValue = 199
        }
        //if a file is recording, fine the file and stream the data into it
        if (mainActivity.recording) {
            mainActivity.files.forEach { csvFile ->
                if (csvFile.isRecording.value) {
                    csvFile.writeFrame(dataFrame, mainActivity.recordingSegment, device?.name ?: "")
                }
            }
        }
    } catch (e: Exception) {
        println("Error parsing message: ${e.message}")
    }
}


//read files in the disk, update them into the instance list, so that the file list ui will be updated
fun updateFileList(context: Context, files: MutableList<CsvFile>,mainActivity: MainActivity) {
    val dir = context.getExternalFilesDir(null)
    val csvFiles = dir?.listFiles { file -> file.extension == "csv" }
    files.clear()
    csvFiles?.let {
        it.sortedByDescending { file -> file.lastModified() }.forEach { file ->
            val csvFile = CsvFile(file)
            files.add(csvFile)
            if (csvFile.file.name == mainActivity.recordingFile){
                    csvFile.isRecording.value = true
            }
            if (csvFile.file.name == mainActivity.expandedFile){
                csvFile.isExpanded.value = true
            }
        }
    }
}

data class CsvFile(
    var file: File, //This class is an extension of the class 'File'

) {
    //The file generated by the app has three layers: file - segment - sensor. A file can include multiple segments, a segment can include multiple sensors.
    //A CsvFile instance record the files' metadata, segment list along with the segment's metadata and sensor list, along with the sensor's metadata
    var segmentList: MutableList<Segment> = mutableListOf()
    var comment: String = ""
    var isRecording = mutableStateOf(false)
    var isExpanded = mutableStateOf(false)
    fun parseCsvFile() {
        val reader = file.bufferedReader()
        var currentSegment: Segment? = null
        var currentSensor: SensorData? = null
        var skipNextLine = false
        segmentList.clear()
        reader.forEachLine { line ->
            if (skipNextLine) {
                skipNextLine = false // 重置标记，跳过当前行
                return@forEachLine
            }
            if (line.isNotEmpty()) {
                val parts = line.split(",").map { it.trim() }

                // file's metadata
                if (parts[0].isNotEmpty()) {
                    when (parts[0]) {
                        "Comment" -> comment = parts[1] // 设置 CsvFile 的注释
                    }
                } else if (parts[0].isEmpty() && parts[1].isEmpty()&& parts[2].isNotEmpty()) {
                    // segment's metadata
                    if (parts[2].startsWith("Segment")) {
                        currentSegment = Segment(name = parts[3])
                        segmentList.add(currentSegment!!)
                    } else if (currentSegment != null) {

                        when {
                            parts[2].startsWith("Comment") -> currentSegment!!.comment = parts[3]
                            parts[2].startsWith("StartTime") -> currentSegment!!.startTime = parts[3]
                            parts[2].startsWith("Sensors") -> {
                            }
                        }
                    }
                } else if (parts[0].isEmpty() && parts[1].isEmpty() && parts[2].isEmpty()) {
                    // Sensors' metadata
                    if (parts[4].startsWith("Sensor")) {
                        currentSensor = SensorData(name = parts[5])
                        currentSegment?.sensorList?.add(currentSensor!!)
                    } else if (currentSensor != null) {
                        when {
                            parts[4].startsWith("gain") -> currentSensor!!.gain = parts[6].toDouble()
                            parts[4].startsWith("Sample rate") -> {
                                currentSensor!!.rate = parts[6].toInt()
                                skipNextLine = true
                            }
                        }
                    }
                }
            }
        }
    }

//When start recording, write a header that describes the segment's metadata into the file.
    fun writeHeader(segment: Segment) {
        val segmentIndex = segmentList.size + 1
        val currentTime = SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(Date())
        val sensorNames = segment.sensorList.joinToString("|") { it.name }

        file.appendText("\n")
        file.appendText(",,Segment $segmentIndex,${segment.name},,\n")
        file.appendText(",,Comment,${segment.comment},,\n")
        file.appendText(",,StartTime,$currentTime,,\n")
        file.appendText(",,Sensors,$sensorNames,,\n")

        //each sensor's metadata
        segment.sensorList.forEachIndexed { index, sensor ->
            file.appendText(",,,,Sensor ${index + 1},${sensor.name}\n")
            file.appendText(",,,,gain,,${sensor.gain}\n")
            file.appendText(",,,,Sample rate,,${sensor.rate}\n")
            file.appendText(",,,,Data,\n")
        }
    }
    //write a frame into the file
    fun writeFrame(dataFrame: DataFrame, segName: String, sensorName: String) {
        val reader = file.bufferedReader()
        val lines = reader.readLines().toMutableList()
        var segmentIndex = -1

        for (i in lines.indices.reversed()) {
            val line = lines[i]
            if (line.startsWith(",,Segment ") && line.contains(segName)) {
                segmentIndex = i
                break
            }
        }

        if (segmentIndex != -1) {
            var sensorFound = false
            for (j in segmentIndex until lines.size) {
                val innerLine = lines[j]
                if (innerLine.startsWith(",,,,Sensor ") && innerLine.contains(sensorName)) {
                    sensorFound = true
                }

                if (sensorFound && innerLine.startsWith(",,,,Data,")) {
                    val dataString = dataFrame.data.joinToString(",")
                    lines[j] = "$innerLine,$dataString"
                    file.writeText(lines.joinToString("\n"))
                    return
                }
            }
        }
    }
}
data class Segment(
    var name: String = "",
    var startTime: String = "",
    var comment: String = "",
    val sensorList: MutableList<SensorData> = mutableListOf()
)

data class SensorData(
    var name: String = "",
    var gain: Double = 0.0,
    var rate: Int = 0,
)

//generate a segment instance according to the device list
fun generateSegment(segName: String, comment: String, devices: List<Device>, useAllSeg: Boolean = false): Segment {
    val segment = Segment(name = segName, comment = comment)
    devices.forEach { device ->
        if (device.record || useAllSeg) {
            val sensorData = SensorData(
                name = device.name,
                gain = device.gain,
                rate = device.rate.toInt()
            )
            segment.sensorList.add(sensorData)
        }
    }
    return segment
}